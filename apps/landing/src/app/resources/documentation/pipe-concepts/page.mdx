---
title: Pipe0 Docs | Field Mode
description: "Learn about Pipes. The processing blocks of enrichment pipelines."
date: 2025-03-07
---

# Pipe Concepts

This page contains additional information about pipes.

## Pipe types

### Single provider pipes

Many pipes use a single provider for processing. Providers can be a third-party service like 
[LeadMagic](https://leadmagic.io) or [ZeroBounce](https://zerobounce.com). Native pipes use Pipe0 as a provider.

### Waterfall pipes

Waterfall pipes use many providers in a cascading sequence. We try provider A. If the data is found, it is returned.
If the data is not found we try provider B. If the data is not found again, we try provider C and so on.

A billing event occurs for the provider that returns a result. Providers that return `no_result`
are not billed.

Waterfall enrichments can drastically increase data coverage. But keep in mind that trying many providers 
can slow down processing speed.

#### Choosing waterfall providers

Waterfall pipes have a `config.providers` option. The option is typically of the type `Array<{ provider: <PROVIDER_NAME> }>`.
If no config is provided, the default config is applied. If you remove a provider from the array, the provider is removed
from your processing sequence.

Providers are processed according to their position in the `config.providers` array. The provider with the index 0 is processed first.
You are encouraged to change the order.


## Field mode

The field mode determines the shape of the <AppLink linkType="pipeConfig">config object</AppLink> a pipe takes.

### Field mode: `static`

Most <AppLink linkType="pipe">pipes</AppLink> have static <AppLink linkType="inputField">input</AppLink> 
and <AppLink linkType="outputField">output fields</AppLink>. When `field_mode` is set to `static`, the 
pipe's in- and outputs are known in advance.

You can point the input fields to different fields or rename the outputs, but the pipe's API is clearly 
defined in advance.

_Example_: 

When using the pipe `people:workemail:waterfall@1`, we use the
input fields `name` and `company_website_url` to generate the output field `work_email`.

### Field mode: `config`

The inputs and outputs of this pipe are not known beforehand. This is the case when the user can define 
input and output fields as part of the pipe configuration.

#### Prompt inputs

A common pattern that uses user-defined in- and outputs is `prompts`. Prompts let the user specify input 
and output fields for a pipe with a special syntax.

##### Prompt example

Prompts have the following structure:

```json
{
  "prompt": {
    "text": "Determine if company {{ input company_name }} is a good customer for my magic wand ðŸª„ business. {{ output reason type=\"json\" schema=\"reason\" description=\"Explain why the customer is a good prospect\" }} {{ output is_good_customer type=\"boolean\" format=\"int\" description=\"a flag that summarized the overall assessment of the customers fit\" }}",
    "json_schemas": {
      "reason": {
        "type": "object",
        "properties": {
          "reason": {
            "type": "string",
            "description": "A summary of why the customer is or isn't a good prospect for my business."
          },
        }
      }
    }
  }
}
```

##### Prompt tags 

Input field tags support the following properties:

| Property      | Example |
| :---        |    :---   | 
| required      | `{{ input company_name required=\"true\" }}`| 

Input field tags support the following properties:

| Property      | Example |
| :---        |    :---   | 
| type      | `{{ output company_name type=\"string\" }}`| 
| description   | `{{ output company_name description=\"Lorem ipsum\" }}`|


## Triggers <span className="badge-new" />

Triggers allow you to run pipes conditionally. You can specify conditions like:

> Run pipe `people:name:split@1` if the field `name` is `completed` and the resolved value `contains` the value `Tom`.

The request for the example above would look like this.
```json
{
	"pipes": [
		{
			"pipe_id": "people:name:split@1",
			"trigger": {
				"action": "run",
				"when": {
					"logic": "and",
					"conditions": [
						{
							"field_name": "name",
							"property": "value",
							"operator": "contains",
							"value": "Tom"
						}
					]
				}
			}
		}
	],
  "input": [...]
}
```

### Trigger Structure

#### action
The action that will be performed if all conditions are evaluated to true.

**Supported values**: `run`.

> Triggers don't bypass other mechanisms of pipe evaluation. Example: If your trigger conditions are met, but required input 
> fields are missing pipe execution will still be `skipped`.


#### when.logic
A logic operator that connects all conditions. <br />
**Supported values**: `and`, `or`.

#### when.conditions[]

A list of conditions. If all conditions evaluate to true, the action will be performed.

#### condition.field_name

A field in your pipeline that will be used for evaluation. This field can be provided by your input values or another pipe as an `output_field`.

> Conditions targeting JSON fields are not supported. To act conditionally on JSON properties, expand them
> into their own fields.

#### condition.property

The property of the target field (`field_name`) that will be evaluated by the `operator` and `value`.

**Supported values**: `value`, `status`.

#### condition.operator

The operator used for comparison. Allowed operators are determined by `property` and the `field.type`.

##### Operators by type

| Property      | Type | Supported operators    |
| :---        |    :---   |         :--- |
| value      | string       | `eq`, `neq`, `contains`   |
| value   | string, date        | `eq`, `neq`, `lt`, `lte`, `gt`, `gte`, `contains`      |
| value   | number        | `eq`, `neq`, `lt`, `lte`, `gt`, `gte`, `contains`      |
| value   | boolean        | `eq`, `neq`, `contains`      |
| status   | /        | `eq`, `neq`, `contains`      |

**Supported values**: `value`, `status`.

#### condition.value

The value to compare against. 

